#include <iostream>
using namespace std;

const int number_of_pointers = 4;
const int empty_key = INT_MAX;


class Node {
private:
    bool Node_full(); 
    bool Node_leaf();

    void split_child(int i, Node* Child);
  
    void Insert_Non_Full(const int key, string data);
    int Count_Keys();
public:
    int array_of_keys [number_of_pointers - 1]; 
    string array_of_data [number_of_pointers - 1];
    Node* Pointers [number_of_pointers]{};
public:
    Node();
    ~Node();
    friend class BTree;
};


class BTree {
public:
    void Insert(const int key, string data);
    bool Delete(const int key);
    string Find(const int key);
public:
    BTree() { root = nullptr; };
    ~BTree() { delete root; };
    friend class Node;
private:
    Node* root;
    string Find_In_Subtree(Node* current_node, int key);

};

Node::Node()
{
    for (int counter = 0; counter <= (number_of_pointers - 2); counter++) {
        array_of_keys[counter] = empty_key;
        array_of_data[counter] = "";
        Pointers[counter] = nullptr;
    }
    Pointers[number_of_pointers - 1] = nullptr;
}

Node::~Node()
{
    delete Pointers[number_of_pointers - 1];
}

bool Node::Node_full ()
{
    if (array_of_keys[number_of_pointers - 2] == empty_key)
        return true;
    return false;
}

bool Node::Node_leaf ()
{
    if (Pointers[0] == nullptr)
        return true;
    return false;
}

int Node::Count_Keys()
{
    int count = 0;
    for (int counter = 0; counter <= (number_of_pointers - 2); counter++) {
        if (array_of_keys[counter] != empty_key) {
            count++;
        }
    }
    return count;
}
string BTree::Find_In_Subtree(Node* current_node, int key)
{
    if (current_node == nullptr)
        return "fault";
    int counter = 0;
    while (counter <= number_of_pointers - 2 && current_node->array_of_keys[counter] <= key)
        counter++;

    if (current_node->array_of_keys[counter - 1] == key)
        return current_node->array_of_data[counter - 1];
    if (current_node->Node_leaf())
        return "not_found";
    return Find_In_Subtree(current_node->Pointers[counter], key);
}

string BTree::Find(const int key)
{
    return Find_In_Subtree(root, key);
}

void BTree::Insert(const int key, string data)
{

    if (root == nullptr)
    {
        root = new Node();
        root->array_of_keys[0] = key;
        root->array_of_data[0] = data;
    }

    if (root->Node_full())
    {  
        Node* New_Root = new Node();
        New_Root->Pointers[0] = root;  
        New_Root->split_child(0, root);

        if (New_Root->array_of_keys[0] < key)
            New_Root->Pointers[1]->Insert_Non_Full(key, data);
        else
            New_Root->Pointers[0]->Insert_Non_Full(key, data);

        root = New_Root;
    }
    else {
        root->Insert_Non_Full(key, data);
    }
}

void Node::split_child(int counter_0, Node* Child)
{
    Node* Right = new Node();
    for (int counter_1 = 0; counter_1 < number_of_pointers - 3; ++counter_1)
    {
        Right->array_of_keys[counter_1] = Child->array_of_keys[counter_1 + (number_of_pointers - 2)];
        Right->array_of_data[counter_1] = Child->array_of_data[counter_1 + (number_of_pointers - 2)];
        Child->array_of_keys[counter_1 + (number_of_pointers - 2)] = empty_key;
        Child->array_of_data[counter_1 + (number_of_pointers - 2)] = "";
    }
    for (int counter_2 = 0; counter_2 < number_of_pointers - 2; counter_2 ++)
    {
        Right->Pointers[counter_2] = Child->Pointers[counter_2 + (number_of_pointers - 2)];
        Child->Pointers[counter_2 + (number_of_pointers - 2)] = nullptr;
    }

    for (int counter_3 = Count_Keys(); counter_3 >= counter_0 + 1; counter_3--) {
        Pointers[counter_3 + 1] = Pointers[counter_3];
    }

    Pointers[counter_0 + 1] = Right;
    for (int counter_4 = Count_Keys() - 1; counter_4 >= counter_0; counter_4--)
    {
        array_of_keys[counter_4 + 1] = array_of_keys[counter_4];
        array_of_data[counter_4 + 1] = array_of_data[counter_4];
    }

    array_of_keys[counter_0] = Child->array_of_keys[number_of_pointers - 3];
    Child->array_of_keys[number_of_pointers - 3] = empty_key;
    array_of_data[counter_0] = Child->array_of_data[number_of_pointers - 3];
    Child->array_of_data[number_of_pointers - 3] = "";
}

void Node::Insert_Non_Full(const int key, string data)
{

    int index = Count_Keys() - 1;

    if (Node_leaf())
    {      
        while (index >= 0 && array_of_keys[index] > key)
        {
            array_of_keys[index + 1] = array_of_keys[index];
            array_of_data[index + 1] = array_of_data[index];
            index--;
        }
        array_of_keys[index + 1] = key;
        array_of_data[index + 1] = data;
    }
    else
    {
        while (index >= 0 && array_of_keys[index] > key)
            index--;
        if (Pointers[index + 1]->Node_full())
        {
            split_child(index + 1, Pointers[index + 1]);
            if (array_of_keys[index + 1] < key) {
                index++;
            }
        }
        Pointers[index + 1]->Insert_Non_Full(key, data);
    }
}

int main()
{
    return 0;
}
